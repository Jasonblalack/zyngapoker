# Features

## 1. Scriptable

Jasy uses a full scripting language to define tasks. This allows the widest flexibility for the developer. Instead of being limited to a configuration like [DSL](http://en.wikipedia.org/wiki/Domain-specific_language) you can interact with data and methods like in a real programming languages (in fact you are writing your tasks in Python 3). Developers are able to modify results of one method and pass the result into a second method. This kind of flexibility allows Jasy being used in a wide array of projects and situations.



## 2. Projects

### Project Dependencies

Each Jasy project is able to define requirements to other projects. These requirements are solved recursively and duplicates (projects with the same name) are filtered out. Projects can also be overridden by projects being higher in the dependency chain.

### Custom Project Layout

Jasy supports a set of layouts inside projects. For adding support for the various 3rd party libraries and frameworks Jasy is able to use a custom set of files and is able to files to internal file IDs (basically the exported name of a file e.g. jQuery exports `$`). There is a [Jasy Compat]() project showcasing how to integrate jQuery, QUnit, Modernizr and Co using a Jasy configuration.

### Project Setup Routines

Some projects are using custom build routines which applies some kind of magic to the code before concatting single files (aka adding intro/outro content, patching files with version numbers, etc.). For these cases Jasy is able to define setup routines which should be executed whenever a project is initially used or updated.

### Remote Projects

Jasy can automatically clone Git projects by all supported URLs from private and public repositories. It uses so called shallow clones to improve download speed and reduced disk space usage. Jasy is smart enough to update branches automatically on every run (reducing the hassle with typical Git sub modules) while keeping tagged versions in their original state. Switching between versions is as easy as updating the configuration file and pushing the change to that file to the server. All other users of the projects will download the new version of the dependency automatically with the next time they execute Jasy.

### Shared Code

Each project in Jasy is able to share actual Python code with other projects. This is conveniently pre-configurd. One only has to add a `jasylibrary.py` to the root folder of a project and add the `@share` decorator to methods which should be shared to the outside. The exported methods will be part of an object called like the project name in the `jasyscript.py` of the including project.




## 3. Permutations

Supports permutations to fully remove code blocks, classes, assets, translations which are not required for the current build. This can happen via manual configuration e.g. disabling `debug` or via permutation which basically means to build every possible variant of the original code which is possible. The behavior of this is fully customizable inside the `jasyscript.py`. 

BTW: Results of all these permutations are also cached individually. And Jasy figures out which file uses which code mutations to not permutate files which are not affected by specific settings.





## 4. JavaScript 

### Parser

Jasy has deep JavaScript language support through being based on a full-blown parser which itself is based on the mature Spidermonkey parser from Mozilla. Jasy even fully supports upcoming features like generators, array comprehension, etc. of JavaScript 1.8. During that process Jasy generates a easy to process [AST](http://en.wikipedia.org/wiki/Abstract_syntax_tree). This `AST` can be used to transform the original code for e.g. API documentation, code formatting, code linting, optimization, etc. Comments are attached to the generated `AST` nodes during parsing the actual code.


### Dependencies

Reliable, automatic dependency analysis for JavaScript is built in. Automatically sorts files by their requirements. Dependency analysis happens with permutations applied (e.g. debug builds might contain classes deployment builds might not contain).


### Compressor

The compressor feature in Jasy removes white space, comments and any formatting from original code using the AST generated by the parser.


### Optimizer

The optimizer feature in Jasy processes the AST before passing it to the compressor. It does a lot of things known from other JavaScript compressors as well. Generally speaking it optimizes code in a very stable fashion and results in comparable output file sizes like [UglifyJS](https://github.com/mishoo/UglifyJS) or [Closure Compiler](https://developers.google.com/closure/compiler/). It out performas [YUI Compressor](http://developer.yahoo.com/yui/compressor/), [qooxdoo](http://qooxdoo.org)'s generator and other older tools by a wide margin.

In detail this means:

- Dead code elimination removes unreachable code in `if`/`else` blocks, conditional statements `?:`, `switch`/`case` and `AND`/`OR` operators.
- Supports comparison of hard-coded or permutation added values for `boolean`, `number` and `string` types.
- Groups single `var` statements into blocks.
- Removes needless blocks (with just one statement)
- Automatically combines strings and numbers (e.g. "Version " + 1.3 => "Version 1.3")
- Optimizes if(-else) statements with expressions as content
  - Translates if-statements without else using `&&` or `||` operators
  - Translates if-statements with else using conditional operator `? :` (especially worth with returns/assignments)
- Removes needless else (if previous if-block ends with a return/throw statement)
- Removes needless parens based on priority analysis on the AST
- Renames file private variables (starting with double underscore by convention)



## 5. Assets

The asset feature in Jasy allows for referencing assets (images, CSS files, ...) via internal IDs instead of URLs or relative paths. This makes adding support for things like CDNs a breeze later on and easily supports different kind of deploy structures.

### Image Sprites

Generating and using image sprites (with easy to use client side API to transparently deal with the original file names).

### Image Animations

Jasy allows defining and using sprite animations via simple JSON/YAML files (for graphically rich animations).


### Deployment

Copies all assets to bundle them in a self contained application folder. This simplifies deployment by a major extend. All relevant files are locally available after deployment.






## 6. Localization

### Locale Data

The locale support in Jasy is build on the industry standard CLDR data used by Microsoft, Oracle, IBM and Co as well. It contains information about date and number formats, calendars, sorting priorities, etc.

Jasy rebuilds the XML files of each locale into an Jasy-enabled project which is dynamically added during processing the permutations ("locale" is one built-in permutatiomn option).

The classes generated by Jasy are super modular and make use of the dependency handling in Jasy. The application developer is able to just use the e.g. long date format info without the other available information and no additional overhead. All data is exported under the `locale` namespace.

Locale data is always using a fallback chain. It exports data starting with the defined locale e.g. `de_AT` and fills in the gaps with a fallback to a language only version e.g. `de` and the `root` defintion as the general fallback. This means that all data should basically export somewhat comparable data. Still it might make sense to add some JavaScript classes on top of these raw data classes to make working with the data itself more convenient.

### Gettext Translations

Translations via Gettext are pretty much standard in the open source world and are available in many programming languages (PHP, Python, â€¦) and Frameworks. Jasy builds on top of *polib* to offer an integrated support for translations build on data available in so called po files. Jasy supports the full range of features supported by the PO file format e.g. multi plural forms / rules, context translations, etc.


- Translate applications with widely support gettext like `po` files.
- Loads translations from PO-files
- Create language specific variants
- Replaces string instances directly inside the original file
- Removes overhead through translation as no function call is needed anymore
- Optimizes template replacement e.g. via %1 into a string "plus" operation
- Jasy inlines translation into the permutated application code. No more lookup for translation texts once compiled.




## 7. Documentation

Jayy is able to generate API data from JavaScripts projects with deep-analysis of dependencies etc. The data could be rendered by the [API Browser](https://github.com/zynga/apibrowser) or any other custom application.

### Package Documentation

Jasy supports package documentation to allow projects to define introduction documentation for every package/namespace.

### Dialects

Jasy generates API data from different JavaScript declarations (core library, native prototype, ...)

- Supports classes, mixins, interfaces, events and properties
- Supports links to native types like `String`, `Array`, etc.
- Merges polyfills to target classes e.g. `String.prototype` even if file is named differently.

### Markdown

Jasy translates [Markdown](http://daringfireball.net/projects/markdown/) content into HTML and applies syntax highlighting to code sections. It uses GitHubs extended high performance [Sundown](https://github.com/tanoku/sundown) Markdown parser and the widely used [Pygments](http://pygments.org/) for syntax highlighting.

### Tags

Support for tags to easily marking classes, modules, methods etc. is built in as well.



## 8. Web Server

The internal web server allows for easily setting up a local web server to deliver the local Jasy based application to the web browser or remote machines. The propose of this server is to make local development easier. 

### Multiple Routes

Jasy is able to define different routes to different targets. It's easy to mix local file delivery with remote mirroring under the same server.

### Proxying / Mirroring

Jasy supports proxying and mirroring remote server requests and using a full offline feature it can also work from cache only without requiring the original mirrored server. This feature is super useful for slow remote servers, for testing machines under different domains (fix CORS issues), etc. The 

### Mime Types

Jasy's web server comes with a good set of additional mime types to support typical HTML5 features like AppCache or modern video formats.




## 9. Scaffolding

For setting up new projects Jasy comes with a pretty powerful scaffolding feature. Scaffolding works like a skeleton or boilerplate project but offers on-top configuration to make that new project directly usable after creation.


### Placeholders

Jasy supports modifiying the original code of the skeleton to match the requirements of the new project. It automatically replaces placeholders in all files by the actual values defined via questions or command line parameters.


### Custom Setup Routines / Questions

The skeleton is able to define questions for confiuguration. These can be answered interactively during project creation or pre-defined via command line parameters. Questions can also be interactive and fine tune the original skeleton in quite powerful ways. For that Jasy supports a custom `jasycreate.py` for writing down custom code which is executed on the files copied over from the skeleton.


### Remote Cloning

New projects can be created by remote hosted projects via Git URLs. Jasy will automatically clone the repository into a new temporary folder and copies over and configures an existing skeleton from this "origin" project.




