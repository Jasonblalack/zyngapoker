# Features

## 1. Scriptable

Jasy uses a full scripting language to define tasks. This allows the widest flexibility for the developer. Instead of being limited to a configuration like [DSL](http://en.wikipedia.org/wiki/Domain-specific_language) you can interact with data and methods like in a real programming languages (in fact you are writing your tasks in Python 3). Developers are able to modify results of one method and pass the result into a second method. This kind of flexibility allows Jasy being used in a wide array of projects and situations.



## 2. Projects

### Project Dependencies

Each Jasy project is able to define requirements to other projects. These requirements are solved recursively and duplicates (projects with the same name) are filtered out. Projects can also be overridden by projects being higher in the dependency chain.

### Custom Project Layout

Jasy supports a set of layouts inside projects. For adding support for the various 3rd party libraries and frameworks Jasy is able to use a custom set of files and is able to files to internal file IDs (basically the exported name of a file e.g. jQuery exports `$`). There is a [Jasy Compat]() project showcasing how to integrate jQuery, QUnit, Modernizr and Co using a Jasy configuration.

### Project Setup Routines

Some projects are using custom build routines which applies some kind of magic to the code before concatting single files (aka adding intro/outro content, patching files with version numbers, etc.). For these cases Jasy is able to define setup routines which should be executed whenever a project is initially used or updated.

### Remote Projects

Jasy can automatically clone Git projects by all supported URLs from private and public repositories. It uses so called shallow clones to improve download speed and reduced disk space usage. Jasy is smart enough to update branches automatically on every run (reducing the hassle with typical Git sub modules) while keeping tagged versions in their original state. Switching between versions is as easy as updating the configuration file and pushing the change to that file to the server. All other users of the projects will download the new version of the dependency automatically with the next time they execute Jasy.

### Shared Code

Each project in Jasy is able to share actual Python code with other projects. This is conveniently pre-configurd. One only has to add a `jasylibrary.py` to the root folder of a project and add the `@share` decorator to methods which should be shared to the outside. The exported methods will be part of an object called like the project name in the `jasyscript.py` of the including project.




## 3. Permutations

Supports permutations to fully remove code blocks, classes, assets, translations which are not required for the current build. This can happen via manual configuration e.g. disabling `debug` or via permutation which basically means to build every possible variant of the original code which is possible. The behavior of this is fully customizable inside the `jasyscript.py`. 

BTW: Results of all these permutations are also cached individually. And Jasy figures out which file uses which code mutations to not permutate files which are not affected by specific settings.





## 4. JavaScript 

### Parser

Jasy has deep JavaScript language support through being based on a full-blown parser which itself is based on the mature Spidermonkey parser from Mozilla. Jasy even fully supports upcoming features like generators, array comprehension, etc. of JavaScript 1.8. During that process Jasy generates a easy to process [AST](http://en.wikipedia.org/wiki/Abstract_syntax_tree). This `AST` can be used to transform the original code for e.g. API documentation, code formatting, code linting, optimization, etc. Comments are attached to the generated `AST` nodes during parsing the actual code.


### Dependencies

Reliable, automatic dependency analysis for JavaScript is built in. Automatically sorts files by their requirements. Dependency analysis happens with permutations applied (e.g. debug builds might contain classes deployment builds might not contain).


### Compressor

The compressor feature in Jasy removes white space, comments and any formatting from original code using the AST generated by the parser.


### Optimizer

The optimizer feature in Jasy processes the AST before passing it to the compressor. It does a lot of things known from other JavaScript compressors as well. Generally speaking it optimizes code in a very stable fashion and results in comparable output file sizes like [UglifyJS](https://github.com/mishoo/UglifyJS) or [Closure Compiler](https://developers.google.com/closure/compiler/). It out performas [YUI Compressor](http://developer.yahoo.com/yui/compressor/), [qooxdoo](http://qooxdoo.org)'s generator and other older tools by a wide margin.

**Details:**

- Dead code elimination removes unreachable code in `if`/`else` blocks, conditional statements `?:`, `switch`/`case` and `AND`/`OR` operators.
- Supports comparison of hard-coded or permutation added values for `boolean`, `number` and `string` types.
- Groups single `var` statements into blocks.
- Removes needless blocks (with just one statement)
- Automatically combines strings and numbers (e.g. "Version " + 1.3 => "Version 1.3")
- Optimizes if(-else) statements with expressions as content
  - Translates if-statements without else using `&&` or `||` operators
  - Translates if-statements with else using conditional operator `? :` (especially worth with returns/assignments)
- Removes needless else (if previous if-block ends with a return/throw statement)
- Removes needless parens based on priority analysis on the AST
- Renames file private variables (starting with double underscore by convention)



## 5. Assets

The asset feature in Jasy allows for referencing assets (images, CSS files, ...) via internal IDs instead of URLs or relative paths. This makes adding support for things like CDNs a breeze later on and easily supports different kind of deploy structures.

### Image Sprites

Generating and using image sprites (with easy to use client side API to transparently deal with the original file names).

### Image Animations

Jasy allows defining and using sprite animations via simple JSON/YAML files (for graphically rich animations).


### Deployment

Copies all assets to bundle them in a self contained folder. This simplifies deployment by a major extend.






## 6. Localization

### Locale Data

- Translate applications with widely support gettext like `po` files.
  - Loads translations from PO-files
  - Create language specific variants
  - Replaces string instances directly inside the original file
  - Removes overhead through translation as no function call is needed anymore
  - Optimizes template replacement e.g. via %1 into a string "plus" operation
- Industry standard CLDR data for localization support (date formats, calenders, etc.)
  - Rebuilds XML files to nicely useable ultra-modular JSON data classes
  - Integrates with dependency system
  - Fast access to data without additional API possible
  - Supports project fallback chain

### Gettext Translations

Jasy inlines translation into the permutated application code. No more lookup for translation texts once compiled.




## 7. Documentation

- Generating API data from JavaScripts projects with deep-analysis of dependencies etc. The data could be rendered by the [API Browser](https://github.com/zynga/apibrowser) or any other custom application.
- Support for package documentation to allow projects to define introduction documentation for every package/node.
- Generates API data from different JavaScript declarations (core library, native prototype, ...)
  - Supports classes, mixins, interfaces, events and properties
  - Supports links to native types like `String`, `Array`, etc.
  - Merges polyfills to target classes e.g. `String.prototype` even if file is named differently.
- Translates [Markdown](http://daringfireball.net/projects/markdown/) content into HTML and applies syntax highlighting to code sections. Uses GitHubs extended high performance [Sundown](https://github.com/tanoku/sundown) Markdown parser and the widely used [Pygments](http://pygments.org/) for syntax highlighting.
- Support tags for easily marking classes, modules, methods etc.



## 8. Web Server

The internal web server allows for easily setting up a local web server to deliver the local Jasy based application to the web browser or remote machines. The propose of this server is to make local development easier. 

### Proxying / Mirroring

Jasy supports proxying and mirroring remote server requests and using a full offline feature it can also work from cache only without requiring the original mirrored server. This feature is super useful for slow remote servers, for testing machines under different domains (fix CORS issues), etc. The 

### Mime Types

Jasy's web server comes with a good set of additional mime types to support typical HTML5 features like AppCache or modern video formats.

### Multiple Routes

Jasy is able to define different routes to different targets. It's easy to mix local file delivery with remote mirroring under the same server.



## 9. Scaffolding

For setting up new projects Jasy comes with a pretty powerful scaffolding feature. Scaffolding works like a skeleton or boilerplate project but offers on-top configuration to make that new project directly usable after creation.

### Remote Cloning

New projects can be created by remote hosted projects via Git URLs. Jasy will automatically clone the repository into a new temporary folder and copies over and configures an existing skeleton from this "origin" project.




